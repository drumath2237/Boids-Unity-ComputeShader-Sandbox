#pragma kernel CSMain

struct BoidsData
{
    float3 position;
    float3 velocity;
};

float3 fillVec;

float effectRange;
int boidsCount;
float3 boundary;

float maxVelocity;
float maxAcceleration;

float alignWeight;
float separationWeight;
float cohesionWeight;

RWStructuredBuffer<BoidsData> boidsData;

bool WithinRange(const BoidsData self, const BoidsData other, const float range)
{
    const float3 dir = other.position - self.position;
    return dot(dir, dir) < range * range;
}

/// \brief ベクトル長を特定の長さに制限する関数
/// \param vec 3次元ベクトル
/// \param length 制限する長さ
/// \return 制限処理を行った後のベクトル。長さが0であればそのまま返す
float3 LimitVector(const float3 vec, const float length)
{
    return dot(vec, vec) == 0 ? vec : normalize(vec) * length;
}

float3 AlignForce(const float effectRange, const int index)
{
    return float3(0, 0, 0);
}

float3 SeparationForce(const float effectRange, const int index)
{
    return float3(0, 0, 0);
}

/// \brief 結合処理
/// \param effectRange 計算対象となるboidsの範囲
/// \param index 加速度の計算対象のboidsのindex
/// \return 加速度
float3 CohesionForce(const float effectRange, const int index)
{
    return float3(0, 0, 0);
}

/// \brief 境界処理
/// \param boid boid
/// \param boundary 境界
/// \return 境界処理を行ったboid
BoidsData BorderTreatment(const BoidsData boid, const float3 boundary)
{
    float3 pos = boid.position;
    float3 vel = boid.velocity;

    if (pos.x > boundary.x)
    {
        pos.x = boundary.x;
        vel = -vel;
    }
    else if (pos.x < -boundary.x)
    {
        pos.x = -boundary.x;
        vel = -vel;
    }

    if (pos.y > boundary.y)
    {
        pos.y = boundary.y;
        vel = -vel;
    }
    else if (pos.y < -boundary.y)
    {
        pos.y = -boundary.y;
        vel = -vel;
    }

    if (pos.z > boundary.z)
    {
        pos.z = boundary.z;
        vel = -vel;
    }
    else if (pos.z < -boundary.z)
    {
        pos.z = -boundary.z;
        vel = -vel;
    }

    BoidsData result;
    result.position = pos;
    result.velocity = vel;

    return result;
}

float3 CalcIndividualForce(const float range, const float index)
{
    const float3 align = AlignForce(range, index);
    const float3 separation = SeparationForce(range, index);
    const float3 cohesion = CohesionForce(range, index);

    return alignWeight * align
        + separationWeight * separation
        + cohesionWeight * cohesion;
}

[numthreads(64,1,1)]
void CSMain(const uint3 id:SV_DispatchThreadID)
{
    BoidsData boid = boidsData[id.x];

    float3 force = CalcIndividualForce(effectRange, id.x);
    force = LimitVector(force, maxAcceleration);

    boid.velocity += force;
    boid.velocity = LimitVector(boid.velocity, maxVelocity);

    boid.position += boid.velocity;

    boid = BorderTreatment(boid, boundary);

    boidsData[id.x] = boid;
}
